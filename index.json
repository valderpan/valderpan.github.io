[{"categories":["R"],"content":"dplyr主要函数： mutate() 对已有列数据变换并添加新的列，类似标准函数transform select() 按照列名筛选列，可结合starts_with，ends_with，contains，matches，one_of，num_range和everything等使用 filter() 按照已定条件对行做过滤，类似标准函数subset arrange() 对数据进行排序，类似标准函数order summarise() 对数据进行汇总操作,可结合group_by使用,类似标注函数aggregate ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:0:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"1.arrange函数对data排序 data # group value # 1 A 13 # 2 B 7 # 3 C 9 # 4 D 21 # 5 E 2 arrange(data,value) #按照value列升序排序 或者 data %\u003e% arrange(value) # group value # 1 E 2 # 2 B 7 # 3 C 9 # 4 A 13 # 5 D 21 arrange(data,desc(value)) #按照value列降序排序 或data %\u003e% arrange(desc(value)) # group value # 1 D 21 # 2 A 13 # 3 C 9 # 4 B 7 # 5 E 2 ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:1:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"2.mutate函数新增一列 mutate()函数是对已有列数据变换并添加为新的列 # 添加一个新的列new，并且new是Sepal.Length和Sepal.Width的乘积： df_mutate\u003c- mutate(iris, new = Sepal.Length * Sepal.Width) head(df_mutate) ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:2:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"3.select函数选取列 按照列名筛选列，可结合starts_with，ends_with，contains，matches，one_of，num_range和everything等使用： # 列名称以Petal开头的列 df_select\u003c- select(iris, starts_with(\"Petal\")) # 列名称以Width结尾的列 df_select\u003c- select(iris, ends_with(\"Width\")) # 列名称包含etal的列 df_select\u003c- select(iris, contains(\"etal\")) # 列名称匹配t的列 df_select\u003c- select(iris, matches(\".t.\")) # 只筛选Petal.Length,Petal.Width两个列 df_select\u003c- select(iris, Petal.Length, Petal.Width) # 筛选所有的变量 df_select\u003c- select(iris, everything()) # 把需要的变量赋值给vars，然后用one_of模式筛选 vars\u003c- c(\"Petal.Length\", \"Petal.Width\") df_select\u003c- select(iris, one_of(vars)) ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:3:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"4.filter() 函数的使用 按照已定条件对行做过滤，类似标准函数subset,在使用filter之前需要了解一下几个逻辑操作符： ==, \u003e, \u003e=, \u003c, \u003c=, %in% \u0026, |, ！, xor() is.na() between(), near() 使用韦恩图表示不同类型连接方式： # 筛选Species是setosa的数据(根据行内容进行选择) df_filter\u003c- filter(iris, Species == \"setosa\") # 筛选Sepal.Length大于5，并且Species是setosa的数据 df_filter\u003c- filter(iris, Sepal.Length \u003e 5 \u0026 Species == \"setosa\") # 筛选Sepal.Length大于5，并且Species包含在c(\"setosa\",\"versicolor\")中的数据 df_filter\u003c- filter(iris, Sepal.Length \u003e 5 \u0026 Species %in%c(\"setosa\",\"versicolor\")) ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:4:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"5.summarise函数的使用： 对数据进行汇总操作,可结合group_by使用： # 计算Sepal.Length的平均值和标准差： df_summarise\u003c- summarise(iris, mean(Sepal.Length), sd(Sepal.Length)) # 按照Species分组，计算Sepal.Length的平均值和标准差 iris_groups\u003c- group_by(iris, Species) df_summarise\u003c- summarise(iris_groups, mean(Sepal.Length), sd(Sepal.Length)) # dplyr的计算是以tbl格式返回的，我们可以转成dataframe, 当然这步没必要，但是为了方便显示： df_summarise\u003c- as.data.frame(df_summarise) #以上代码可以简写为： iris %\u003e% group_by(Species) %\u003e% summarise(`mean(Sepal.Length)`=mean(Sepal.Length),`sd(Sepal.Length)`=sd(Sepal.Length)) ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:5:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"6.inner_join、left_join、right_join、full_join 参考网页：https://www.jianshu.com/p/1f4c7bfed3d4 数据类型： ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:6:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"合并连接 内连接 inner_join 函数 内连接的结果是一个新数据框，其中包含键、 x 值和 y 值。我们使用 by 参数告诉 dplyr 哪个变量是键： x %\u003e% inner_join(y, by = \"key\") # A tibble: 2 x 3 key val_x val_y \u003cdbl\u003e \u003cchr\u003e \u003cchr\u003e 1 1 x1 y1 2 2 x2 y2 外连接 内连接保留同时存在于两个表中的观测， 外连接则保留至少存在于一个表中的观测。外连接有 3 种类型。 左连接：保留 x 中的所有观测。 右连接：保留 y 中的所有观测 全连接：保留 x 和 y 中的所有观测。 left_join函数 左连接：保留 x 中的所有观测 \u003e left_join(x, y, by = \"key\") # A tibble: 3 x 3 key val_x val_y \u003cdbl\u003e \u003cchr\u003e \u003cchr\u003e 1 1 x1 y1 2 2 x2 y2 3 3 x3 NA 另：如果x中的key变量，在y中有多个同样的key，那么所有的结合可能都会罗列出来 \u003e left_join(x, y1, by = \"key\") # A tibble: 4 x 3 key val_x val_y \u003cdbl\u003e \u003cchr\u003e \u003cchr\u003e 1 1 x1 y1 2 2 x2 y2 3 2 x2 y5 4 3 x3 NA right_join函数 右连接：保留 y 中的所有观测 \u003e right_join(x, y, by = \"key\") # A tibble: 3 x 3 key val_x val_y \u003cdbl\u003e \u003cchr\u003e \u003cchr\u003e 1 1 x1 y1 2 2 x2 y2 3 4 NA y3 full_join函数 全连接：保留 x 和 y 中的所有观测。 \u003e full_join(x, y, by = \"key\") # A tibble: 4 x 3 key val_x val_y \u003cdbl\u003e \u003cchr\u003e \u003cchr\u003e 1 1 x1 y1 2 2 x2 y2 3 3 x3 NA 4 4 NA y3 dplyr中这些连接函数对应基础函数merge中的功能表： dplyr这几种函数的来源SQL中对应的功能： ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:6:1","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"筛选链接 筛选连接匹配观测的方式与合并连接相同，但前者影响的是观测，而不是变量。筛选连接有两种类型。 semi_join(x, y)： 保留 x 表中与 y 表中的观测相匹配的所有观测。 anti_join(x, y)： 丢弃 x 表中与 y 表中的观测相匹配的所有观测 semi_join函数： 保留 x 表中与 y 表中的观测相匹配的所有观测 \u003e semi_join(x, y, by = \"key\") # A tibble: 2 x 2 key val_x \u003cdbl\u003e \u003cchr\u003e 1 1 x1 2 2 x2 anti_join函数： 丢弃 x 表中与 y 表中的观测相匹配的所有观测 \u003e anti_join(x, y, by = \"key\") # A tibble: 1 x 2 key val_x \u003cdbl\u003e \u003cchr\u003e 1 3 x3 ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:6:2","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"7.case_when() 可实现**==多条件判断并可以添加标签的函数==**，这在我们对数据进行分类整理中十分的实用，这个函数中的参数可以这样分：一部分是判断条件，另一部分是所要做的标签 可结合mutate函数进行使用 源文件格式： tuesdata$movies %\u003e% mutate(clean_test = case_when( #判断筛选到a时，将a替换为b clean_test == \"ok\" ~ \"Pass Bechdel\", clean_test == \"dubious\" ~ \"Dubious\", clean_test == \"men\" ~ \"About men\", clean_test == \"notalk\" ~ \"No talk\", clean_test == \"nowomen\" ~ \"No women\", )) 判断clean_test这一列，当筛选到前面的字符串时，将其替换为后面的字符串！ 更改后： ","date":"2022-01-19","objectID":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/:7:0","tags":["编程"],"title":"[dplyr]数据清洗与整理","uri":"/dplyr%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%95%B4%E7%90%86/"},{"categories":["R"],"content":"【stringr】处理字符串 【数据与平行世界】R数据处理-4:stringr与正则表达式 1.【str_extract、str_extract_all】 字符串提取 字符提取函数str_extract和str_extract_all，对字符串进行提取，str_extract_all函数返回所有的匹配结果。 # 提取第一个匹配到的字符 str_extract(string = \"banana\",pattern = \"a\") ## [1] \"a\" # 提取所有匹配到的字符（返回列表） str_extract_all(string = \"banana\",pattern = \"a\") ## [[1]] ## [1] \"a\" \"a\" \"a\" # 提取所有匹配到的字符（返回矩阵） str_extract_all(string = \"banana\",pattern = \"a\", simplify = T) ## [,1] [,2] [,3] ## [1,] \"a\" \"a\" \"a\" 需求一：添加一列，此列为原df里面某一列中的几个字符。例如去掉等位的染色体ID #使用正则表达式匹配 dd %\u003e% mutate(CHR=str_extract(X1,\"Chr\\\\d+\")) #BaseR dd %\u003e% mutate(CHR=substr(X1,1,5)) 2.【str_c】字符串拼接 stringr str_c需要传入两个字符参数，另外,collapse参数是将两个字符参数连接，sep参数是将两个字符参数内部的字符连接 即：「sep用于指定变量内连接符，collapse用于指定变量间连接符！」 所谓变量间：如：c(“a”,“b”)；c(“c”,“d”) – 这就是两个变量，指定他们之间的连接符用的就是 collapse； 所谓变量内：如：c(“a”,“b”) – a和 b都属于一个向量，所以他们两之间的连接符用 sep来指定！ # 默认无向量分割符拼接 str_c(\"a\",\"b\") ## [1] \"ab\" # 指定向量分隔符 str_c(\"a\",\"b\",sep = \"_\") ## [1] \"a_b\" # 指定向量折叠符 str_c(c(\"a\",\"b\",\"c\"),collapse = \"_\") ## [1] \"a_b_c\" # 混合应用 str_c(c(\"a\",\"b\"),c(\"c\",\"d\"),sep = \"/\",collapse = \"_\") ## [1] \"a/c_b/d\" str_c(c('a','b'),c('c','d'),collapse = '\\\\') ## [1] \"ac\\\\bd\" 使用baseR实现上述： ## 顺便再科普一下paste和paste0的用法: 两者的唯一区别在于paste0的sep=\"\" paste(\"a\",\"b\") # 默认用空格连接 # [1] \"a b\" paste0(\"a\",\"b\") # 默认无向量分割符拼接 # [1] \"ab\" paste(\"a\",\"b\",sep = \"_\") # 指定分割符,但是paste0没有sep参数！ # [1] \"a_b\" paste(c(\"a\",\"b\",\"c\"),collapse = \"_\") # paste元素内部连接 # [1] \"a_b_c\" paste0(c(\"a\",\"b\",\"c\"),collapse = \"_\") # paste0元素内部连接 # [1] \"a_b_c\" # 混合应用 paste(c(\"a\",\"b\"),c(\"c\",\"d\"),sep = \"/\",collapse = \"_\") # [1] \"a/c_b/d\" paste0(c(\"a\",\"b\"),c(\"c\",\"d\"), collapse = \"_\") # [1] \"ac_bd\" 3.【str_split、str_split_fixed】字符串分割 字符分割函数str_split和str_split_fixed，对字符串进行分割。 # 字符分割，返回列表 str_split(string = \"banana\",pattern = \"\") ## [[1]] ## [1] \"b\" \"a\" \"n\" \"a\" \"n\" \"a\" # 字符分割，返回矩阵 str_split(string = \"banana\",pattern = \"\",simplify = T) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] \"b\" \"a\" \"n\" \"a\" \"n\" \"a\" # 字符分割，指定分割块数 str_split_fixed(string = \"banana\",pattern = \"\",n = 3) ## [,1] [,2] [,3] ## [1,] \"b\" \"a\" \"nana\" 4.【str_sub、str_subset】 提取字符串 函数str_sub和str_subset str_sub函数通过指定开始和结束位置，提取出字符串的部分字符串。str_subset函数通过匹配模式，过滤出满足模式的字符串。 ###### 按位置提取：###### # 字符提取（正向索引） str_sub(string = \"banana\",start = 1,end = 3) ## [1] \"ban\" # 字符提取（反向索引） str_sub(string = \"banana\",start = -2,end = -1) ## [1] \"na\" # 字符提取，并赋值 x \u003c- \"banana\" str_sub(string = x,start = 1,end = 1) \u003c- \"A\" print(x) ## [1] \"Aanana\" ###### 按匹配模式提取 ###### # 字符串提取（返回字符串） str_subset(string = c(\"java\",\"sql\",\"python\"),pattern = \"^s\") ## [1] \"sql\" # 字符串提取（返回位置） str_which(string = c(\"java\",\"sql\",\"python\"),pattern = \"^s\") ## [1] 2 5.【str_count】 统计字符串出现的次数 字符计数函数str_count，计算字符串中指定字符的个数。 # 单个目标字符计数 str_count(string = c(\"sql\",\"json\",\"java\"),pattern = \"s\") ## [1] 1 1 0 # 多个目标字符计数 str_count(string = c(\"sql\",\"json\",\"java\"),pattern = c(\"s\",\"j\",\"a\")) ## [1] 1 1 2 # 元字符查找计数（fixed包裹元字符） str_count(string = \"a..b\",pattern = fixed(\".\")) ## [1] 2 6.【str_detect】字符检查 # 字符检查函数`str_detect`，检查字符串中是否包含指定字符，返回逻辑向量。 str_detect(string = c(\"sql\",\"json\",\"java\"),pattern = \"s\") ## [1] TRUE TRUE FALSE 7.【str_dup】字符复制 字符复制函数str_dup，将字符向量重复若干次，返回重复后的字符向量。 str_dup(string = c(\"sql\",\"json\",\"java\"),times = 2) ## [1] \"sqlsql\" \"jsonjson\" \"javajava\" 8.【str_glue】字符格式化 字符串格式化函数str_glue，用花括号{}表示占位符，括号内的变量被替换成全局变量值。 # 定义全局变量 name \u003c- \"jack\" age \u003c- 12 # 字符串格式化 str_glue(\"My name is {name},\",\"\\nmy age is {age}.\") ## My name is jack, ## my age is 12. 9.【str_length】字符串长度 字符串长度函数str_length，计算字符串长度。 str_length(string = \"banana\") ## [1] 6 # 功能等同于R自带的函数： nchar(\"banana\") 10.【str_locate、str_locate_all】字符位置提取 字符位置提取函数str_locate和str_locate_all,返回匹配到的字符的位置。 # 返回第一个匹配到的字符的位置 str_locate(string = \"banana\",pattern = \"a\") ## start end ## [1,] 2 2 # 返回所有匹配到的字符的位置 str_locate_all(string = \"banana\",pattern = \"a\") ## [[1]] ## start end ## [1,] 2 2 ## [2,] 4 4 ## [3,] 6 6 11.【str_pad】字符补齐 字符补齐函数str_pad，用于在字符串中添加单个字符，可选择添加的位置，在参数side中进行设置。 # 默认字符串左边补齐 str_pad(string = \"jack\",width = 6,pad = \"S\") ## [1] \"SSjack\" # 字符串右边补齐 str_pad(string = \"jack\",width = 6,side = \"right\",pad = \"S\") ## [1] \"jackSS\" # 字符串两边补齐 str_p","date":"2022-01-19","objectID":"/stringr%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["编程"],"title":"[stringr]处理字符串","uri":"/stringr%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["技术"],"content":"使用Hugo搭建个人博客步骤： 1.安装Hugo、Git等必要软件 2.执行 hugo new site MyBlog创建本地博客文件夹 3.执行git init将文件夹交给git管理 4.执行git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt指令下载主题 5.修改博客根目录下的config.toml文件 6.执行hugo new posts/my-first-post.md添加第一篇博客 7.执行hugo server -D -e production在本地预览博客 8.Github创建对应的仓库，注意仓库名 9.执行hugo -D编译静态博客页面 10.执行git init将public文件夹交给git管理 ","date":"2022-01-19","objectID":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/:0:0","tags":["技术"],"title":"使用Hugo搭建个人博客步骤","uri":"/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/"},{"categories":["R"],"content":"所有关于因子factor的操作，均可使用R中的forcats包 官方网站:https://github.com/tidyverse/forcats R包安装与加载： install.packages('forcats') library('forcats') 使用数据的格式如下图： ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:0:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"1.常规作图： ggplot(dd,aes(y=Number,x=Description))+ geom_bar(stat='identity')+coord_flip() ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:1:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"2.利用fct_reorder函数排序： 这个函数让排序按照一个数值变量来！！ ggplot(dd,aes(y=Number,x=fct_reorder(Description,Number)))+ geom_bar(stat='identity')+coord_flip() 即将Description一列按照Number列的数量进行排序，默认为从大到小。 这个操作也可用于分面： 数据预处理： tt \u003c- gapminder %\u003e%filter(country %in% c(\"Norway\", \"Portugal\", \"Spain\", \"Austria\")) 数据展示： 常规作图： ggplot(tt,aes(year, lifeExp)) + geom_line(size=0.8) + facet_wrap(~country, nrow = 1) #or #ggplot(tt,aes(year, lifeExp)) + geom_line(size=0.8) + # facet_wrap(vars(country), nrow = 1) 默认结果是按照分面列的字母排序来的。 使用fct_reorder进行分面作图： ggplot(tt,aes(x=year, y=lifeExp)) + geom_line(size=0.8) + facet_wrap(~fct_reorder(country,lifeExp), nrow = 1) #or tt %\u003e% mutate(country = fct_reorder(country, lifeExp)) %\u003e% # default: order by median ggplot(aes(year, lifeExp)) + geom_line() + facet_wrap(vars(country), nrow = 1) 因为country列和lifeExp列是一对多的关系，默认是按照中位数去排 中位数这个默认操作，是可以换的，比如换成最低值,只需在fct_reorder中添加第三个参数即可。 ggplot(tt,aes(x=year, y=lifeExp)) + geom_line(size=0.8) + facet_wrap(~fct_reorder(country,lifeExp,min), nrow = 1) 也可以换成max去试试。你还可以自定义函数，比如说最大值与最小值之差，也就是按照差值大小来排: ggplot(tt,aes(x=year, y=lifeExp)) + geom_line(size=0.8) + facet_wrap(~fct_reorder(country,lifeExp,function(x) { max(x) - min(x) }), nrow = 1) 反过来排序，只需把函数定义为最小值减最大值，就和上图反过来了。或者是加上fct_rev()函数。 ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:2:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"3.利用fct_relevel函数对因子进行手动排序 library(palmerpenguins) 数据预览： 常规作图： ggplot(penguins,aes(y=species))+geom_bar(width=0.8) 这里是直接利用species出现的次数来当做x轴进行画图 默认是用a-z进行排序，自下而上 !fct_relevel对因子进行手动排序： ggplot(penguins,aes(y=fct_relevel(species,\"Gentoo\", \"Adelie\",'Chinstrap')))+geom_bar(width = 0.8) 默认是先设置的在最下面，逐渐往上展示 ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:3:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"4.利用fct_infreq对因子按照频率进行排序，默认频率最大的在最下边 ggplot(penguins,aes(y=fct_infreq(species)))+geom_bar(width = 0.8) ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:4:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"5.利用fct_rev可以将上面的排序进行反转 ggplot(penguins,aes(y=fct_infreq(species) %\u003e% fct_rev()))+ geom_bar(width = 0.8) ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:5:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["R"],"content":"6.fct_lump_n() 汇总某一列中所有的内容，指定一个n定义出现频率前n个的内容，其他内容可以更改 举例：将main_genre列出现频率最高的前7个正常打印，剩余的其他的均打印为\"Less common\\n genres\" 原格式： mutate(main_genre = fct_lump_n(main_genre, 7,other_level = \"Less common\\n genres\") 即出现频率由高到低，前7个最高的不变，其余的都更改为\"Less common\\n genres\" 更改后： ","date":"2022-01-19","objectID":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/:6:0","tags":["编程"],"title":"[forcats]关于因子的操作","uri":"/forcats%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["杂记"],"content":"个人博客的第一篇文章，以此记录","date":"2022-01-19","objectID":"/firstpost/","tags":["杂记"],"title":"My Blog 第一篇博客","uri":"/firstpost/"},{"categories":["杂记"],"content":"现在是2022年01月19日，我重新创建了个人博客网站并写下了这第一篇博客。 希望在以后的日子里可以在这里记录知识与心情，在记录中学习，在记录中感悟。 风雨过后不一定有美好的天空，不是天晴就会有彩虹。时间过得快不要紧，怕的是在夜里幻想明天的乘风破浪，激情在第二天就已烟消云散。天亮之前会有一段漆黑、伸手不见五指的时间，希望我们都能成为渴望成为的那个人！ ​ 潘浩然 于聊城 ​ 2022.01.19 ","date":"2022-01-19","objectID":"/firstpost/:0:0","tags":["杂记"],"title":"My Blog 第一篇博客","uri":"/firstpost/"}]